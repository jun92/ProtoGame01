<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dice Poker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Dice Styles */
        .die {
            width: 32px;
            height: 32px;
            background-color: white;
            border-radius: 6px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            color: black;
            font-weight: bold;
            font-size: 18px;
            border: 1px solid #e5e7eb;
        }

        .die-dot {
            width: 6px;
            height: 6px;
            background-color: black;
            border-radius: 50%;
        }

        /* Simple dot layouts for 1-6 */
        .face-1 {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .face-2 {
            display: flex;
            justify-content: space-between;
            padding: 4px;
        }

        .face-2 .die-dot:nth-child(2) {
            align-self: flex-end;
        }

        .face-3 {
            display: flex;
            justify-content: space-between;
            padding: 4px;
        }

        .face-3 .die-dot:nth-child(2) {
            align-self: center;
        }

        .face-3 .die-dot:nth-child(3) {
            align-self: flex-end;
        }

        .face-4 {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-content: space-between;
            padding: 4px;
        }

        .face-5 {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-content: space-between;
            padding: 4px;
        }

        .face-5 .die-dot:nth-child(3) {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .face-5 {
            position: relative;
        }

        .face-6 {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-content: space-between;
            padding: 4px;
        }

        .face-6 .die-dot {
            margin: 1px;
        }

        /* Simplified for 6 */

        /* Better Dice Face Implementation using Grid */
        .dice-face {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            padding: 4px;
            gap: 2px;
        }

        .dot {
            background-color: black;
            border-radius: 50%;
            width: 100%;
            height: 100%;
        }

        /* Dot positioning classes */
        .d-1 {
            grid-area: 1 / 1;
        }

        .d-2 {
            grid-area: 1 / 2;
        }

        .d-3 {
            grid-area: 1 / 3;
        }

        .d-4 {
            grid-area: 2 / 1;
        }

        .d-5 {
            grid-area: 2 / 2;
        }

        .d-6 {
            grid-area: 2 / 3;
        }

        .d-7 {
            grid-area: 3 / 1;
        }

        .d-8 {
            grid-area: 3 / 2;
        }

        .d-9 {
            grid-area: 3 / 3;
        }
    </style>
</head>

<body class="bg-gray-900 text-gray-100 h-screen flex overflow-hidden font-sans">

    <!-- Left Panel: Poker Hands Reference -->
    <aside class="w-80 bg-gray-800 border-r border-gray-700 flex flex-col shadow-lg z-10">
        <div class="p-4 border-b border-gray-700 bg-gray-850">
            <h2 class="text-xl font-bold text-yellow-400 flex items-center gap-2">
                <span>ðŸ“œ</span> Hand Rankings
            </h2>
        </div>
        <div class="flex-1 overflow-y-auto p-4 space-y-4">

            <!-- Five of a Kind -->
            <div class="bg-gray-700/50 p-3 rounded-lg border border-gray-600">
                <div class="flex justify-between items-center mb-2">
                    <span class="font-semibold text-purple-300">Five of a Kind</span>
                    <span class="text-xs bg-purple-900 text-purple-200 px-2 py-0.5 rounded">Highest</span>
                </div>
                <div class="flex gap-1 justify-center">
                    <div class="die">6</div>
                    <div class="die">6</div>
                    <div class="die">6</div>
                    <div class="die">6</div>
                    <div class="die">6</div>
                </div>
                <p class="text-xs text-gray-400 mt-2 text-center">All five dice show the same number.</p>
            </div>

            <!-- Four of a Kind -->
            <div class="bg-gray-700/50 p-3 rounded-lg border border-gray-600">
                <div class="font-semibold text-blue-300 mb-2">Four of a Kind</div>
                <div class="flex gap-1 justify-center">
                    <div class="die">5</div>
                    <div class="die">5</div>
                    <div class="die">5</div>
                    <div class="die">5</div>
                    <div class="die text-gray-400 border-gray-400">2</div>
                </div>
            </div>

            <!-- Full House -->
            <div class="bg-gray-700/50 p-3 rounded-lg border border-gray-600">
                <div class="font-semibold text-green-300 mb-2">Full House</div>
                <div class="flex gap-1 justify-center">
                    <div class="die">4</div>
                    <div class="die">4</div>
                    <div class="die">4</div>
                    <div class="die">1</div>
                    <div class="die">1</div>
                </div>
            </div>

            <!-- Straight -->
            <div class="bg-gray-700/50 p-3 rounded-lg border border-gray-600">
                <div class="font-semibold text-yellow-300 mb-2">Straight</div>
                <div class="flex gap-1 justify-center">
                    <div class="die">1</div>
                    <div class="die">2</div>
                    <div class="die">3</div>
                    <div class="die">4</div>
                    <div class="die">5</div>
                </div>
            </div>

            <!-- Three of a Kind -->
            <div class="bg-gray-700/50 p-3 rounded-lg border border-gray-600">
                <div class="font-semibold text-orange-300 mb-2">Three of a Kind</div>
                <div class="flex gap-1 justify-center">
                    <div class="die">3</div>
                    <div class="die">3</div>
                    <div class="die">3</div>
                    <div class="die text-gray-400 border-gray-400">5</div>
                    <div class="die text-gray-400 border-gray-400">1</div>
                </div>
            </div>

            <!-- Two Pair -->
            <div class="bg-gray-700/50 p-3 rounded-lg border border-gray-600">
                <div class="font-semibold text-pink-300 mb-2">Two Pair</div>
                <div class="flex gap-1 justify-center">
                    <div class="die">2</div>
                    <div class="die">2</div>
                    <div class="die">6</div>
                    <div class="die">6</div>
                    <div class="die text-gray-400 border-gray-400">4</div>
                </div>
            </div>

            <!-- One Pair -->
            <div class="bg-gray-700/50 p-3 rounded-lg border border-gray-600">
                <div class="font-semibold text-gray-300 mb-2">One Pair</div>
                <div class="flex gap-1 justify-center">
                    <div class="die">1</div>
                    <div class="die">1</div>
                    <div class="die text-gray-400 border-gray-400">3</div>
                    <div class="die text-gray-400 border-gray-400">5</div>
                    <div class="die text-gray-400 border-gray-400">6</div>
                </div>
            </div>

        </div>
    </aside>

    <!-- Center Panel: Dice Arena -->
    <main class="flex-1 flex flex-col relative bg-green-900">
        <!-- Table Felt Texture/Gradient -->
        <div
            class="absolute inset-0 bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-green-800 via-green-900 to-gray-900 opacity-80 pointer-events-none">
        </div>

        <!-- Header/Top Bar -->
        <div class="relative z-10 p-6 flex justify-between items-start">
            <div>
                <h1 class="text-4xl font-bold text-white drop-shadow-md tracking-wider">DICE POKER</h1>
                <p class="text-green-200 opacity-80">Roll the dice, make a hand!</p>
            </div>
            <div class="bg-black/30 backdrop-blur-sm px-4 py-2 rounded-full border border-white/10">
                <span class="text-sm text-gray-300 uppercase tracking-widest">Current Score</span>
                <div class="text-2xl font-mono text-yellow-400 text-right">0</div>
            </div>
        </div>

        <!-- Dice Rolling Area (Center) -->
        <div class="relative z-10 flex-1 flex flex-col items-center justify-center p-8">

            <!-- Held Dice Container -->
            <div id="held-dice-container"
                class="flex gap-4 mb-8 min-h-[60px] p-4 bg-black/20 rounded-xl border border-white/10 w-full max-w-xl justify-center items-center transition-all">
                <span class="text-gray-500 text-sm italic" id="held-placeholder">Click dice to hold them here</span>
            </div>

            <!-- Dice Container -->
            <div id="dice-arena"
                class="relative w-full max-w-3xl h-80 border-4 border-dashed border-green-700/50 rounded-3xl bg-green-800/20 backdrop-blur-sm mb-8 overflow-hidden transition-all">
                <div id="arena-placeholder"
                    class="absolute inset-0 flex items-center justify-center text-center opacity-50 pointer-events-none">
                    <div>
                        <div class="text-6xl mb-4">ðŸŽ²</div>
                        <p class="text-xl font-medium text-green-100">Dice Arena</p>
                        <p class="text-sm text-green-300">Dice will be rolled here</p>
                    </div>
                </div>
            </div>

            <!-- Controls -->
            <div class="flex flex-col items-center gap-4">
                <button id="roll-btn"
                    class="bg-gradient-to-b from-yellow-400 to-yellow-600 hover:from-yellow-300 hover:to-yellow-500 text-black font-bold py-4 px-12 rounded-full shadow-[0_4px_0_rgb(161,98,7),0_8px_16px_rgba(0,0,0,0.3)] active:shadow-none active:translate-y-1 transition-all text-xl uppercase tracking-wider transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
                    Roll Dice
                </button>
                <div class="text-green-300 font-mono text-sm">
                    Rolls Left: <span id="rolls-left" class="text-yellow-400 font-bold text-lg">3</span>
                </div>
            </div>
        </div>

        <!-- Footer -->
        <div class="relative z-10 p-4 text-center text-green-400/40 text-sm">
            Click dice to hold/unhold. 3 rolls per turn.
        </div>
    </main>

    <!-- Right Panel: History -->
    <aside class="w-72 bg-gray-800 border-l border-gray-700 flex flex-col shadow-lg z-10">
        <div class="p-4 border-b border-gray-700 bg-gray-850 flex justify-between items-center">
            <h2 class="text-xl font-bold text-blue-400 flex items-center gap-2">
                <span>ðŸ•’</span> History
            </h2>
            <button class="text-xs text-gray-500 hover:text-gray-300 transition-colors">Clear</button>
        </div>

        <div class="flex-1 overflow-y-auto p-4 space-y-3" id="history-list">
            <!-- History items will be added here -->
        </div>
    </aside>

    <script>
        const rollBtn = document.getElementById('roll-btn');
        const diceArena = document.getElementById('dice-arena');
        const arenaPlaceholder = document.getElementById('arena-placeholder');
        const heldContainer = document.getElementById('held-dice-container');
        const heldPlaceholder = document.getElementById('held-placeholder');
        const rollsLeftSpan = document.getElementById('rolls-left');
        const historyList = document.getElementById('history-list');

        // Game State
        let rollsLeft = 3;
        let heldDiceValues = []; // Array of numbers
        let currentArenaDice = []; // Array of PhysicsDie objects
        let isRolling = false;

        // Helper to create a die element
        function createDieElement(value) {
            const die = document.createElement('div');
            die.className = 'die dice-face absolute shadow-xl cursor-pointer hover:scale-110 transition-transform';
            die.style.width = '48px';
            die.style.height = '48px';

            // Dot positions for each number 1-6
            const dotMap = {
                1: ['d-5'],
                2: ['d-3', 'd-7'],
                3: ['d-3', 'd-5', 'd-7'],
                4: ['d-1', 'd-3', 'd-7', 'd-9'],
                5: ['d-1', 'd-3', 'd-5', 'd-7', 'd-9'],
                6: ['d-1', 'd-3', 'd-4', 'd-6', 'd-7', 'd-9']
            };

            updateDieFace(die, value, dotMap);
            return die;
        }

        function updateDieFace(dieElement, value, dotMap) {
            dieElement.innerHTML = '';
            (dotMap[value] || []).forEach(posClass => {
                const dot = document.createElement('div');
                dot.className = `dot ${posClass}`;
                dieElement.appendChild(dot);
            });
        }

        // Physics Class for a single Die
        class PhysicsDie {
            constructor(arenaWidth, arenaHeight, startX, startY) {
                this.width = 48;
                this.height = 48;
                this.radius = 28;
                this.arenaWidth = arenaWidth;
                this.arenaHeight = arenaHeight;

                // Initial Position
                if (startX !== undefined && startY !== undefined) {
                    this.x = startX;
                    this.y = startY;
                    this.vx = 0;
                    this.vy = 0;
                    this.stopped = true; // Static if spawned manually
                } else {
                    // Throw Logic
                    this.x = (arenaWidth / 2) - (this.width / 2) + (Math.random() * 120 - 60);
                    this.y = arenaHeight + 50 + (Math.random() * 50);
                    this.vx = (Math.random() - 0.5) * 20;
                    this.vy = -(Math.random() * 15 + 25);
                    this.stopped = false;
                }

                // Rotation
                this.rotation = Math.random() * 360;
                this.rotSpeed = (Math.random() - 0.5) * 30;

                // Physics Properties
                this.friction = 0.98;
                this.wallBounce = 0.6;

                // DOM Element
                this.value = Math.floor(Math.random() * 6) + 1;
                this.element = createDieElement(this.value);

                // Interaction: Click to Hold
                this.element.addEventListener('click', (e) => {
                    if (isRolling) return;
                    // Note: We removed the 'stopped' check to allow holding even if slightly moving, 
                    // but ideally user waits. 'isRolling' covers the main animation phase.
                    holdDie(this);
                });

                diceArena.appendChild(this.element);
            }

            update() {
                if (this.stopped) return;

                // Apply Velocity
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotSpeed;

                // Wall Collisions
                if (this.x <= 0) { this.x = 0; this.vx = -this.vx * this.wallBounce; }
                if (this.x + this.width >= this.arenaWidth) { this.x = this.arenaWidth - this.width; this.vx = -this.vx * this.wallBounce; }
                if (this.y <= 0) { this.y = 0; this.vy = -this.vy * this.wallBounce; }
                if (this.y + this.height >= this.arenaHeight) {
                    this.y = this.arenaHeight - this.height;
                    this.vy = -this.vy * this.wallBounce;
                    this.vx *= 0.9;
                }

                // Air Friction
                this.vx *= this.friction;
                this.vy *= this.friction;
                this.rotSpeed *= 0.95;

                // Stop Condition
                // Relaxed condition: just check velocity.
                if (Math.abs(this.vx) < 0.1 && Math.abs(this.vy) < 0.1) {
                    this.stopped = true;
                }

                // Tumble Effect
                if (!this.stopped && (Math.abs(this.vx) > 1 || Math.abs(this.vy) > 1)) {
                    if (Math.random() > 0.8) {
                        this.value = Math.floor(Math.random() * 6) + 1;
                        const dotMap = {
                            1: ['d-5'],
                            2: ['d-3', 'd-7'],
                            3: ['d-3', 'd-5', 'd-7'],
                            4: ['d-1', 'd-3', 'd-7', 'd-9'],
                            5: ['d-1', 'd-3', 'd-5', 'd-7', 'd-9'],
                            6: ['d-1', 'd-3', 'd-4', 'd-6', 'd-7', 'd-9']
                        };
                        updateDieFace(this.element, this.value, dotMap);
                    }
                }

                // Render
                this.element.style.transform = `translate(${this.x}px, ${this.y}px) rotate(${this.rotation}deg)`;
            }
        }

        function resolveCollisions(dice) {
            const iterations = 8;
            for (let k = 0; k < iterations; k++) {
                for (let i = 0; i < dice.length; i++) {
                    for (let j = i + 1; j < dice.length; j++) {
                        const d1 = dice[i];
                        const d2 = dice[j];
                        if (d1.stopped && d2.stopped) continue; // Skip if both stopped (optimization)

                        const c1x = d1.x + d1.width / 2;
                        const c1y = d1.y + d1.height / 2;
                        const c2x = d2.x + d2.width / 2;
                        const c2y = d2.y + d2.height / 2;

                        let dx = c2x - c1x;
                        let dy = c2y - c1y;
                        let distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance === 0) { dx = (Math.random() - 0.5); dy = (Math.random() - 0.5); distance = Math.sqrt(dx * dx + dy * dy); }

                        const minDistance = d1.radius + d2.radius;

                        if (distance < minDistance) {
                            const overlap = minDistance - distance;
                            const nx = dx / distance;
                            const ny = dy / distance;
                            const separationFactor = 0.5;

                            d1.x -= nx * overlap * separationFactor;
                            d1.y -= ny * overlap * separationFactor;
                            d2.x += nx * overlap * separationFactor;
                            d2.y += ny * overlap * separationFactor;

                            const dvx = d2.vx - d1.vx;
                            const dvy = d2.vy - d1.vy;
                            const velAlongNormal = dvx * nx + dvy * ny;

                            if (velAlongNormal > 0) continue;

                            const restitution = 0.5;
                            let jVal = -(1 + restitution) * velAlongNormal;
                            jVal /= 2;

                            d1.vx -= jVal * nx;
                            d1.vy -= jVal * ny;
                            d2.vx += jVal * nx;
                            d2.vy += jVal * ny;

                            d1.rotSpeed += (Math.random() - 0.5) * 5;
                            d2.rotSpeed += (Math.random() - 0.5) * 5;
                        }
                    }
                }
            }
        }

        // Hold Logic
        function holdDie(physicsDie) {
            if (heldDiceValues.length >= 5) return;

            // Remove from Arena
            physicsDie.element.remove();
            const index = currentArenaDice.indexOf(physicsDie);
            if (index > -1) currentArenaDice.splice(index, 1);

            // Add to Held
            heldDiceValues.push(physicsDie.value);
            renderHeldDice();

            // Check End Turn
            if (heldDiceValues.length === 5) {
                endTurn();
            }
        }

        function unholdDie(value, index) {
            if (isRolling || rollsLeft === 0) return; // Cannot unhold if rolling or no rolls left (unless we allow unhold to just sit there?)
            // Actually, if rollsLeft is 0, the turn is over, so this shouldn't be clickable.

            // Remove from Held
            heldDiceValues.splice(index, 1);
            renderHeldDice();

            // Add back to Arena (Static)
            const arenaWidth = diceArena.clientWidth;
            const arenaHeight = diceArena.clientHeight;
            // Spawn at random position in top half
            const x = Math.random() * (arenaWidth - 50);
            const y = Math.random() * (arenaHeight / 2);

            const newDie = new PhysicsDie(arenaWidth, arenaHeight, x, y);
            newDie.value = value; // Restore value
            // Update visual
            const dotMap = {
                1: ['d-5'],
                2: ['d-3', 'd-7'],
                3: ['d-3', 'd-5', 'd-7'],
                4: ['d-1', 'd-3', 'd-7', 'd-9'],
                5: ['d-1', 'd-3', 'd-5', 'd-7', 'd-9'],
                6: ['d-1', 'd-3', 'd-4', 'd-6', 'd-7', 'd-9']
            };
            updateDieFace(newDie.element, value, dotMap);

            currentArenaDice.push(newDie);
        }

        function renderHeldDice() {
            heldContainer.innerHTML = '';
            if (heldDiceValues.length === 0) {
                heldContainer.appendChild(heldPlaceholder);
                return;
            }

            heldDiceValues.forEach((val, idx) => {
                const die = createDieElement(val);
                die.className = 'die dice-face relative shadow-md cursor-pointer hover:scale-110 transition-transform'; // Relative for flex container
                die.addEventListener('click', () => unholdDie(val, idx));
                heldContainer.appendChild(die);
            });
        }

        function endTurn() {
            isRolling = false;
            rollBtn.disabled = false;
            rollBtn.textContent = "New Round";
            rollsLeft = 0;
            rollsLeftSpan.textContent = 0;

            // Calculate Result
            const finalHand = [...heldDiceValues, ...currentArenaDice.map(d => d.value)];
            console.log("Turn Ended. Final Hand:", finalHand);

            // Add to History (Mockup for now)
            const historyItem = document.createElement('div');
            historyItem.className = 'bg-gray-700/30 p-3 rounded border border-gray-700 hover:bg-gray-700/50 transition-colors animate-fade-in';
            historyItem.innerHTML = `
                <div class="flex justify-between items-center mb-2">
                    <span class="text-sm font-bold text-gray-300">Hand Result</span>
                    <span class="text-xs text-gray-500">${new Date().toLocaleTimeString()}</span>
                </div>
                <div class="flex gap-1 opacity-80 scale-75 origin-left">
                    ${finalHand.map(v => `<div class="die" style="width:24px;height:24px;font-size:12px;">${v}</div>`).join('')}
                </div>
            `;
            historyList.prepend(historyItem);
        }

        function startNewRound() {
            rollsLeft = 3;
            rollsLeftSpan.textContent = rollsLeft;
            heldDiceValues = [];
            renderHeldDice();

            // Clear Arena
            currentArenaDice.forEach(d => d.element.remove());
            currentArenaDice = [];

            rollBtn.textContent = "Roll Dice";

            // Show placeholder
            if (arenaPlaceholder) {
                arenaPlaceholder.style.opacity = '0.5';
                diceArena.classList.add('border-dashed', 'bg-green-800/20');
                diceArena.classList.remove('bg-green-800/40');
            }
        }

        // Main Roll Logic
        rollBtn.addEventListener('click', () => {
            if (rollBtn.textContent === "New Round") {
                startNewRound();
                return;
            }

            if (rollsLeft <= 0) return;

            // Disable button
            rollBtn.disabled = true;
            isRolling = true;
            rollsLeft--;
            rollsLeftSpan.textContent = rollsLeft;

            // Clear previous arena dice (only the ones in arena, held ones stay)
            currentArenaDice.forEach(d => d.element.remove());
            currentArenaDice = [];

            // Hide placeholder
            if (arenaPlaceholder) {
                arenaPlaceholder.style.opacity = '0';
                diceArena.classList.remove('border-dashed', 'bg-green-800/20');
                diceArena.classList.add('bg-green-800/40');
            }

            // Create new dice
            const diceToSpawn = 5 - heldDiceValues.length;
            const arenaWidth = diceArena.clientWidth;
            const arenaHeight = diceArena.clientHeight;

            for (let i = 0; i < diceToSpawn; i++) {
                currentArenaDice.push(new PhysicsDie(arenaWidth, arenaHeight));
            }

            // Animation Loop
            let animationId;
            const startTime = Date.now();

            function animate() {
                let allStopped = true;

                // 1. Update positions
                currentArenaDice.forEach(die => {
                    die.update();
                    if (!die.stopped) allStopped = false;
                });

                // 2. Resolve Collisions
                resolveCollisions(currentArenaDice);

                // Force stop after 3 seconds
                if (Date.now() - startTime > 3000) {
                    allStopped = true;
                }

                if (!allStopped) {
                    animationId = requestAnimationFrame(animate);
                } else {
                    cancelAnimationFrame(animationId);
                    rollBtn.disabled = false;
                    isRolling = false;

                    // Finalize positions
                    const finalValues = currentArenaDice.map(d => d.value);
                    console.log("Roll Result:", finalValues);

                    // Check Auto-End conditions
                    if (rollsLeft === 0) {
                        endTurn();
                    }
                }
            }

            animate();
        });
    </script>
</body>

</html>